# -*- coding: utf-8 -*-
"""cv_hw3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OIobUcVCrP2_JcRYLXdSAmHNnVYifw8y
"""

import cv2
import numpy as np
import scipy.io
from scipy import signal
import scipy
import matplotlib.pyplot as plt

point3D = np.loadtxt('/content/Point3D.txt', delimiter=' ')
point2D1 = np.load('/content/image1.npy')
point2D2 = np.load('/content/image2.npy')
img1 = cv2.imread('/content/image1.jpeg')
img2 = cv2.imread('/content/image2.jpeg')

def Projection_Matrix(point2D, point3D):
    ########################################################################
    # TODO:                                                                #
    #   Using 2D coordinator and 3D coordinator,                           #
    #   , calculate the 3D to 2D projection matrix P                       #
    ########################################################################
    num_points = len(point2D)
    assert len(point3D) == num_points

    A = np.zeros((2 * num_points, 12))

    for i in range(num_points):
        u, v = point2D[i, 0], point2D[i, 1]
        X, Y, Z = point3D[i, 0], point3D[i, 1], point3D[i, 2]

        A[2 * i] = [X, Y, Z, 1, 0, 0, 0, 0, -u * X, -u * Y, -u * Z, -u]
        A[2 * i + 1] = [0, 0, 0, 0, X, Y, Z, 1, -v * X, -v * Y, -v * Z, -v]

    _, _, V = np.linalg.svd(A)
    M = V[-1, :].reshape(3, 4)

    ########################################################################
    #                                                                      #
    #                           End of your code                           #
    #                                                                      #
    ########################################################################
    return M

P1 = Projection_Matrix(point2D1, point3D)
print('Projection Matrix of chessboard_1：')
print(P1)
P2 = Projection_Matrix(point2D2, point3D)
print('Projection Matrix of chessboard_2：')
print(P2)

# Verify the projection matrix (P), use P to project the 3D coordinator to 2D coordinates
# input: P, 3D world coordinator, output: 2D image coordinator
def Verify(P,point3D):
    lenPoints = len(point3D)
    ThreeD = np.zeros((lenPoints,4),dtype=np.float32)
    for i in range(lenPoints):
        for j in range(3):
            ThreeD[i,j]=point3D[i,j]

    for i in range(lenPoints):
        ThreeD[i,3]=1

    TwoDD = np.zeros((lenPoints,3),dtype=np.float32)

    for i in range(lenPoints):
        TwoDD[i] = P.dot(ThreeD[i])
        TwoDD[i] = TwoDD[i]/TwoDD[i,-1]

    SE = 0.000

    for i in range(lenPoints):
        SE = SE + np.square(TwoDD[i,0]-point2D1[i,0])+np.square(TwoDD[i,1]-point2D1[i,1])
    RMSE = np.sqrt(SE/lenPoints)

    return RMSE, TwoDD

def Project(img, point2D, TwoD, save_name):
    x = point2D[:,0]
    y = point2D[:,1]
    x1 = TwoD[:,0]
    y1 = TwoD[:,1]
    fig = plt.figure()
    img12 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(20,10))
    plt.plot(x,y,"o", label="original point")
    plt.plot(x1,y1,"x", label="projected point")
    plt.legend(loc='upper right')
    plt.imshow(img12)
    plt.savefig('/content/output/' + save_name + '.png')

RMSE1, TwoDD1 = Verify(P1,point3D)
RMSE2, TwoDD2 = Verify(P2,point3D)
print(RMSE1, RMSE2)

Project(img1, point2D1, TwoDD1,save_name='verify of chessboard_1')

Project(img2, point2D2, TwoDD2,save_name='verify of chessboard_2')

def KRt(P):
    ########################################################################
    # TODO:                                                                #
    #   Extract the intrinsic matrix (K), rotation matrix (R)              #
    #   , and translation vector(T) from the projection matrix.            #
    ########################################################################

    K2 = P[:, :3]

    R = np.linalg.inv(K2) @ P
    RT = R[:, :3]

    K_inv = np.linalg.inv(K2)
    RT = K_inv @ P

    R1 = RT[:, :3]
    T = RT[:, 3]

    ########################################################################
    #                                                                      #
    #                           End of your code                           #
    #                                                                      #
    ########################################################################
    return K2, R1, T

K1, R1, T1 = KRt(P1)
print('K1:')
print(K1)
print('R1:')
print(R1)
print('T1:')
print(T1)
K2, R2, T2 = KRt(P2)
print('K2:')
print(K2)
print('R2:')
print(R2)
print('T2:')
print(T2)

np.savetxt("/content/output/intrinsic matrices of chessboard_1.txt",K1)
np.savetxt("/content/output/rotation matrices of chessboard_1.txt",R1)
np.savetxt("/content/output/translation vectors of chessboard_1.txt",T1)
np.savetxt("/content/output/intrinsic matrices of chessboard_2.txt",K2)
np.savetxt("/content/output/rotation matrices of chessboard_2.txt",R2)
np.savetxt("/content/output/translation vectors of chessboard_2.txt",T2)

def ReProject2D(K, R, T, point2D, point3D):
    lenPoints = len(point3D)
    Pro = np.zeros((3,4),dtype=np.float32)
    Pro[0,0] = 1
    Pro[1,1] = 1
    Pro[2,2] = 1
    Rt = np.zeros((4,4),dtype=np.float32)
    for i in range(3):
        for j in range(3):
            Rt[i,j]=R[i,j]
    Rt[0,3]=T[0]
    Rt[1,3]=T[1]
    Rt[2,3]=T[2]
    Rt[3,3] = 1
    KPRt = K.dot(Pro).dot(Rt)

    ThreeD = np.zeros((lenPoints,4),dtype=np.float32)
    for i in range(lenPoints):
        for j in range(3):
            ThreeD[i,j]=point3D[i,j]

    for i in range(lenPoints):
        ThreeD[i,3]=1

    TwoD = np.zeros((lenPoints,3),dtype=np.float32)
    for i in range(lenPoints):
        TwoD[i] = KPRt.dot(ThreeD[i])
        TwoD[i] = TwoD[i]/TwoD[i,-1]

    SE = 0.000
    for i in range(lenPoints):
        SE = SE + np.square(TwoD[i,0]-point2D[i,0])+np.square(TwoD[i,1]-point2D[i,1])

    RMSE = np.sqrt(SE/lenPoints)

    SEX = 0.000
    for i in range(lenPoints):
        SEX = SEX + np.square(TwoD[i,0]-point2D[i,0])

    SEY = 0.000
    for i in range(lenPoints):
        SEY = SEY + np.square(TwoD[i,1]-point2D[i,1])

    return RMSE, TwoD, SEX, SEY

RMSE1, TwoD1, SE_X1, SE_Y1 = ReProject2D(K1, R1, T1, point2D1, point3D)
RMSE2, TwoD2, SE_X2, SE_Y2 = ReProject2D(K2, R2, T2, point2D2, point3D)

print("RMSE of 1st image: ",RMSE1)
print("RMSE of 2nd image: ",RMSE2)

Project(img1, point2D1, TwoD1,save_name='ReProject2D of chessboard_1')

Project(img2, point2D2, TwoD2,save_name='ReProject2D of chessboard_2')

from visualize import visualize

T11 = T1.reshape(3,1)
T22 = T2.reshape(3,1)

save_name='3D'
visualize(point3D, R1, T1.reshape(3,1), R2, T2.reshape(3,1),save_name)

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# 读取图像
image_path = '/content/image3.jpg'  # 替换为你的图像路径
img = cv2.imread(image_path)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Shi-Tomasi角点检测参数
max_corners = 50  # 期望检测的角点数目
quality_level = 0.01  # 角点检测质量水平
min_distance = 10  # 最小角点之间的欧氏距离

# 检测角点
corners = cv2.goodFeaturesToTrack(gray, max_corners, quality_level, min_distance)
corners = np.intp(corners)

# 在图像上绘制角点
for corner in corners:
    x, y = corner.ravel()
    cv2.circle(img, (x, y), 20, (255, 0, 0), -1)  # 绘制圆圈表示角点

# 显示带有角点标记的图像
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()